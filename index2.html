<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>LOP読み込み</title>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/101/three.min.js"></script>
       	<!-- マウスコントロールのためのOrbitControl.jsを読み込む -->
        <script src="./js/controls/OrbitControls.js"></script>

        <!-- マーカの軌跡を描くために読み込む -->
		<script src='./js/lines/LineSegmentsGeometry.js'></script>
		<script src='./js/lines/LineGeometry.js'></script>
		<script src='./js/lines/WireframeGeometry2.js'></script>

        <script src='./js/lines/LineMaterial.js'></script>
		<script src='./js/lines/LineSegments2.js'></script>
		<script src='./js/lines/Line2.js'></script>
        <script src='./js/lines/Wireframe.js'></script>   
        <!--
        <script src ='./js/libs/dat.gui.min.js'></script>
        -->


        <style>
            body{
                margin: 0;
                overflow: hidden;
            }
            .block_l, .block_c, .block_r{
                cursor: pointer;
                text-align: center;
                border: 2px solid white;
                float:left;
                border-color: white;
                background-color: black;
                width: 30.0%;
                color:white;
                font-size:xx-large;
                padding: 10pt;
            }
            .myCheckbox{
                font-size:xx-large;
                margin:	0 0px 5px 10px;
            }
            input[type=checkbox] {
                width: 40px;
                height: 40px;
                vertical-align: middle;
            }
        </style>          
    </head>

    <body>
        <!--出力するdiv-->


        <div>
            <div onClick="onXZ()" class="block_l">前額面</div>
            <div onClick="onYZ()" class="block_c">矢状面</div>
            <div onClick="onXY()" class="block_r">水平面</div>
            <form name="form1" class="myCheckbox">
                <input type="checkbox" name="showObj" value="マーカ" checked="checked">マーカ
                <input type="checkbox" name="showObj" value="リンク" checked="checked">リンク
                <input type="checkbox" name="showObj" value="軌跡" checked="checked">軌跡
            </form>
            <div id="WebGL-output"></div>
        </div>

        <script>
            //グローバル変数
            var mkr = [];       //マーカの座標
            var sphere = [];    //マーカのMesh
            var iMkrNum = 12;   //マーカ最大数
            var iDataCount=200; //フレーム最大数
            var faveZ;
            var iFrameR = 0;
            var iFrameL;
            var iFrameOffset = 100;
            var iLinkFrom = [2,4,6,8,3,5,7,9,2,4];//リンクFrom
            var iLinkTo = [4,6,8,10,5,7,9,11,3,5];//リンクTo
            var iLinkSide = [0,0,0,0,1,1,1,1,2,2];//0:左　1:右　2:左->右
            var cylinder = [];  //リンクのMesh
            var strLOPPath = "./data/LOP2.csv";
            var strGaitPath = "./data/LOP2_Gait.csv";

            var mkrGroup = new THREE.Group();
            var linkGroup = new THREE.Group();
            var trajectoryGroup = new THREE.Group();
            var show_marker;
            var show_link;
            var show_trajectory;

            var bxy = 1;//水平面の表裏
            var byz = 1;//矢状面の表裏
            var bxz = 1;//前額面の表裏




            //ページの読み込みを待って、getCSVを呼ぶ
            window.addEventListener('load',getLOPCSV);

            //リサイズのイベントハンドラ
            window.addEventListener('resize',onResize,false);

            var canW = window.innerWidth; //canvas横:任意値 
            var canH = window.innerHeight; //canvas縦:任意値
            var scene,camera,renderer,controls,datObj,cubeTexture,mesh;　


            //▼LOPのCSVを読み込む
            function getLOPCSV()
            {
                var req = new XMLHttpRequest(); // HTTPでファイルを読み込むためのXMLHttpRrequestオブジェクトを生成
                req.open("get", strLOPPath, true); // アクセスするファイルを指定
                req.send(null); // HTTPリクエストの発行
                
                // レスポンスが返ってきたらconvertCSVtoArray()を呼ぶ	
                req.onload = function()
                {
                    convertLOPCSVtoArray(req.responseText); // 渡されるのは読み込んだCSVデータ
                    //読み込み終わったらGaitのCSVを読み込む
                    getGaitCSV();
                }
                // 読み込んだCSVデータを二次元配列に変換する関数の定義
                function convertLOPCSVtoArray(str)
                { 
                    // 読み込んだCSVデータが文字列として渡される
                    var result = []; // 最終的な二次元配列を入れるための配列
                    var tmp = str.split("\n"); // 改行を区切り文字として行を要素とした配列を生成
                
                    var i, j,iMk;
                    var fmaxZ=0.0;
                    var fminZ=999.0;

                    //1行目を読んでマーカ数を調べる
                    for(iMk=0; iMk<iMkrNum; iMk++)
                    {
                        mkr[iMk] = [];
                    }

                    var iF=0;
                    for( i=1; i<tmp.length; i++ )
                    {
                        var tmpline = [];
                        //カンマで区切った1行ずつ文字を取得
                        tmpline = tmp[i].split(',');

                        j = 0;
                        for( iMk=0; iMk<iMkrNum; iMk++ )
                        {
                            var tmpvec=new THREE.Vector3(tmpline[++j],tmpline[++j],tmpline[++j]);
                            mkr[iMk].push(tmpvec);

                            //Z軸の最大値と最高値を更新
                            if( fmaxZ < tmpvec.z)
                            {
                                fmaxZ = tmpvec.z;
                            }
                            if( fminZ > tmpvec.z)
                            {
                                fminZ = tmpvec.z;
                            }                    
                        }
                
                        iF++;

                        if( iF >= iDataCount)
                        {
                            break;
                        }
                    }
                    //高さの平均値を出す（+演算子は文字列から数値を取り出す）
                    faveZ = ( (+fmaxZ) + (+fminZ) )/2;
                }
            }

            //▼GaitのCSVを読み込む
            function getGaitCSV()
            {
                var req = new XMLHttpRequest(); // HTTPでファイルを読み込むためのXMLHttpRrequestオブジェクトを生成
                req.open("get", strGaitPath, true); // アクセスするファイルを指定
                req.send(null); // HTTPリクエストの発行
                
                // レスポンスが返ってきたらconvertCSVtoArray()を呼ぶ	
                req.onload = function()
                {
                    convertGaitCSVtoArray(req.responseText); // 渡されるのは読み込んだCSVデータ
                    //読み込み終わったらメイン関数を呼び出す
                    main();
                }
                // 読み込んだCSVデータを二次元配列に変換する関数の定義
                function convertGaitCSVtoArray(str)
                { 
                    // 読み込んだCSVデータが文字列として渡される
                    var result = []; // 最終的な二次元配列を入れるための配列
                    var tmp = str.split("\n"); // 改行を区切り文字として行を要素とした配列を生成
                    var tmpline = [];
                    //2行目を読み込み
                    tmpline = tmp[1].split(',');
                    //右立脚(%)-右両脚支持(%)分のフレームが右と左のオフセット
                    iFrameOffset = parseInt((parseFloat(tmpline[4]) - parseFloat(tmpline[8]))*iDataCount/100);
                    //console.log(iFrameOffset);
                }
            }
           //▼ メイン関数
           function main()
            {
		        //if(!Detector.webgl)Detector.addGetWebGLMessage();//WebGL環境確認
		        scene = new THREE.Scene();


                // create a render and set the size
                renderer = new THREE.WebGLRenderer();
                renderer.setClearColor(new THREE.Color(0xEEEEEE));
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;

                //床
                var planeGeometry = new THREE.PlaneGeometry(200,200,1,1);
                var planeMaterial = new THREE.MeshLambertMaterial({color:0xbbbbbb});
                //planeMaterial.side = THREE.DoubleSide;
                var plane = new THREE.Mesh(planeGeometry,planeMaterial);
                plane.receiveShadow = true;
                //plane.rotation.x = 1*Math.PI;
                plane.position.set(0,0,0);
                scene.add(plane);

                //LOPをシーンに追加
                createLOP();

                // 自然光
                var ambientLight = new THREE.AmbientLight(0x0c0c0c);
                scene.add(ambientLight);

                // スポットライト
                var spotLight = new THREE.SpotLight(0xffffff);
                spotLight.position.set(-50,80,400);
                spotLight.target.position.set(scene.position);
                spotLight.castShadow = true;
                spotLight.shadow.mapSize.width = 1000;
                spotLight.shadow.mapSize.height = 1000;
                spotLight.shadow.camera.near=100;
                spotLight.shadow.camera.far=500;
                scene.add(spotLight);
                //-- スポットライトの向きを表示する
                //var cameraHelper = new THREE.CameraHelper(spotLight.shadow.camera);
                //scene.add(cameraHelper);

                //軸
                var axis = new THREE.AxesHelper( 50 );
                axis.position.set(0,0,0);
                scene.add( axis);

                // カメラ:透視投影 (視野角,画面サイズ,カメラの見える範囲最小値,最大値)
		        camera = new THREE.PerspectiveCamera( 40, canW / canH, 1, 5000);
		        scene.add(camera);
                camera.up = new THREE.Vector3(0,0,1);//Z UPにする
		        camera.position.set( -200, 300, 100);
                camera.lookAt(scene.position);
                
                //コントローラー
                orbitcontrols = new THREE.OrbitControls(camera, renderer.domElement);
                orbitcontrols.maxDistance = 400;
                orbitcontrols.target.set(0,0,faveZ);//回転中心を設定
                              
                // add the output of the renderer to the html element
                document.getElementById("WebGL-output").appendChild(renderer.domElement);
            
            /*
                //▼チェックボックスのコントロールパネル
                var controls = new function()
                {
                    this.show_marker = true;
                    this.show_link = true;
                    this.show_trajectory = true;
                };
                var gui = new dat.GUI();
                gui.add(controls,"show_marker");
                gui.add(controls,"show_link");
                gui.add(controls,"show_trajectory");
*/
                renderScene();


                function createLOP()
                {
                    //▼ここではオブジェクトを追加するだけ。実際の位置はrenderScene()で設定する
                    //▼マーカ
                    var sphereGeometry = new THREE.SphereGeometry(1.5,20,20);
                    var sphereMaterial = new THREE.MeshLambertMaterial({color:0x7777ff});
                    for(var iMk=1; iMk<iMkrNum; iMk++ )
                    {
                        sphere[iMk] = new THREE.Mesh(sphereGeometry, sphereMaterial);
                        sphere[iMk].castShadow=true;
                        mkrGroup.add(sphere[iMk]);
                    }
                    scene.add(mkrGroup);

                    //▼リンク ここではダミーの位置に追加するのみ
                    for(var iLink=0; iLink < iLinkFrom.length; iLink++ )
                    {
                        var col;
                        switch( iLinkSide[iLink])
                        {
                            case 0:
                                col = 0x0000ff;
                                break;
                            case 1:
                                col = 0xff0000;
                                break;
                            default:
                                col = 0x00ff00;
                        }                        
                        var material = new THREE.MeshLambertMaterial( { color: col } );
                        cylinder[iLink] = new THREE.Mesh(new THREE.CylinderGeometry(.5, .5, 1, 0, 0, true), material);
                        cylinder[iLink].castShadow=true;
                        linkGroup.add(cylinder[iLink]);
                        //scene.add(cylinder[iLink]);
                    }
                    scene.add(linkGroup);

                    //▼ リンクの軌跡を描く
                    for(var iMk=1; iMk<iMkrNum; iMk++ )
                    {
                        //scene.add(createLOPTrajectory(iMk));
                        trajectoryGroup.add(createLOPTrajectory(iMk));
                    }   
                    scene.add(trajectoryGroup);
                    //LOPの軌跡オブジェクトを作成
                    function createLOPTrajectory(iMk)
                    {
                        var positions = [];
                        var colors = [];     
                        var color = new THREE.Color();

                        for ( var i = 0; i < iDataCount; i++ ) 
                        {
                            positions.push( mkr[iMk][i].x, mkr[iMk][i].y, mkr[iMk][i].z);
                            color.setHSL( i/iDataCount , 1.0, 0.5 );
                            colors.push( color.r, color.g, color.b );
                        }

                        var geometry = new THREE.LineGeometry();
                        geometry.setPositions( positions );
                        geometry.setColors( colors );
                        
                        matLine = new THREE.LineMaterial( {
                            color: 0xffffff,
                            linewidth: .004,//5, // in pixels
                            vertexColors: THREE.VertexColors,
                            dashed: false
                        } );

                        line = new THREE.Line2( geometry, matLine );
                    
                        line.computeLineDistances();
                        line.scale.set( 1, 1, 1 );

                        return line;
                    }
                }
                function renderScene()
                {
                    iFrameR++;;
                    if( iFrameR >= iDataCount)
                    {
                        iFrameR = 0;
                    }
                    iFrameL = iFrameR + iFrameOffset;
                    if( iFrameL >= iDataCount)
                    {
                        iFrameL -= iDataCount;
                    }

                    //▼　マーカの位置の移動
                    for(var iMk=1; iMk<iMkrNum; iMk++ )
                    {
                        if( iMk % 2 == 0){
                            sphere[iMk].position.set(mkr[iMk][iFrameR].x, mkr[iMk][iFrameR].y, mkr[iMk][iFrameR].z);
                        }else{
                            sphere[iMk].position.set(mkr[iMk][iFrameL].x, mkr[iMk][iFrameL].y, mkr[iMk][iFrameL].z);
                        }
                    }

                    //▼ リンクの位置の移動
                    for(var iLink=0; iLink < iLinkFrom.length; iLink++ )
                    {
                        var iFrameFrom;
                        var iFrameTo;
                        switch( iLinkSide[iLink])
                        {
                            case 0:
                                iFrmaeFrom = iFrameR;
                                iFrmaeTo = iFrameR;
                                break;
                            case 1:
                                iFrmaeFrom = iFrameL;
                                iFrmaeTo = iFrameL;
                                break;
                            default:
                                iFrmaeFrom = iFrameR;
                                iFrmaeTo = iFrameL;
                        }
                        moveCilynder(mkr[iLinkFrom[iLink]][iFrmaeFrom], mkr[iLinkTo[iLink]][iFrmaeTo], cylinder[iLink]);
                    }                    

                    //▼コントロールに合わせて表示/非表示を変更する
                    mkrGroup.children.forEach(function(child){
//                        child.visible = controls.show_marker;
                        child.visible = document.form1.showObj[0].checked;
                    });
                    linkGroup.children.forEach(function(child){
                        //child.visible = controls.show_link;
                        child.visible = document.form1.showObj[1].checked;
                    });
                    trajectoryGroup.children.forEach(function(child){
                        //child.visible = controls.show_trajectory;
                        child.visible = document.form1.showObj[2].checked;
                    });

                    requestAnimationFrame(renderScene);//60fpsで再生しようとする
                    orbitcontrols.update();
                    renderer.render(scene, camera);
                }

                //▼　リンクの線をVecFromからVecToに向ける。長さ1のCylinderを最初に作っておく
                //　　http://himadeus.hatenadiary.jp/entry/2013/04/28/142846
                function moveCilynder(vecFrom,vecTo,cylinder)
                {
                    //From -> Toのベクトルを作る
                    var v = vecTo.clone().sub(vecFrom);
                    var len = v.length();
                    //向きを変える
                    if (len > 0.001) 
                    {
                        cylinder.rotation.z = Math.acos(v.y/len);
                        cylinder.rotation.y = 0.5*Math.PI + Math.atan2(v.x, v.z);
                        cylinder.rotation.order = 'YZX';
                    }
                    //位置を移動
                    cylinder.position.x = (parseFloat(vecFrom.x) + parseFloat(vecTo.x))/2;
                    cylinder.position.y = (parseFloat(vecFrom.y) + parseFloat(vecTo.y))/2;
                    cylinder.position.z = (parseFloat(vecFrom.z) + parseFloat(vecTo.z))/2;
                    //長さを変える
                    cylinder.scale.set(1,len,1);
                }
            }
            function onResize()
            {
                canW = window.innerWidth ;
                canH = window.innerHeight;
                camera.aspect = canW / canH;
                camera.updateProjectionMatrix();
                renderer.setSize(canW, canH);
            }
            

            //▼前額面
            function onXZ()
            {
                bxz *=-1;
		        camera.position.set( 0, bxz*400, 0);                
            }
            //▼矢状面
            function onYZ()
            {
                byz *=-1;
		        camera.position.set( byz*400, 0, 0);                
            }
            //▼水平面
            function onXY()
            {
                bxy*=-1;
		        camera.position.set( 0, 0, bxy*400);  
            }	
        </script>
    </body>
</html>